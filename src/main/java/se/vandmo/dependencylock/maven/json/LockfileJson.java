package se.vandmo.dependencylock.maven.json;

import static java.lang.String.format;
import static java.util.Locale.ROOT;
import static java.util.Objects.requireNonNull;
import static se.vandmo.dependencylock.maven.json.JsonUtils.getNonBlankStringValue;
import static se.vandmo.dependencylock.maven.json.JsonUtils.possiblyGetStringValue;
import static se.vandmo.dependencylock.maven.json.JsonUtils.readJson;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.node.ArrayNode;
import com.fasterxml.jackson.databind.node.JsonNodeFactory;
import com.fasterxml.jackson.databind.node.ObjectNode;
import java.io.IOException;
import java.io.Reader;
import java.io.UncheckedIOException;
import java.io.Writer;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.stream.Stream;
import org.apache.maven.plugin.MojoExecutionException;
import se.vandmo.dependencylock.maven.Artifact;
import se.vandmo.dependencylock.maven.ArtifactIdentifier;
import se.vandmo.dependencylock.maven.Artifacts;
import se.vandmo.dependencylock.maven.Dependencies;
import se.vandmo.dependencylock.maven.Dependency;
import se.vandmo.dependencylock.maven.Extension;
import se.vandmo.dependencylock.maven.Extensions;
import se.vandmo.dependencylock.maven.LockFileAccessor;
import se.vandmo.dependencylock.maven.LockableEntitiesWithArtifact;
import se.vandmo.dependencylock.maven.LockedProject;
import se.vandmo.dependencylock.maven.Lockfile;
import se.vandmo.dependencylock.maven.Parent;
import se.vandmo.dependencylock.maven.Parents;
import se.vandmo.dependencylock.maven.Plugin;
import se.vandmo.dependencylock.maven.Plugins;
import se.vandmo.dependencylock.maven.Profiled;

public final class LockfileJson implements Lockfile {

  private static final String V2 = "2";
  private static final String V3 = "3";
  private final LockFileAccessor dependenciesLockFile;

  private LockfileJson(LockFileAccessor dependenciesLockFile) {
    this.dependenciesLockFile = dependenciesLockFile;
  }

  public static LockfileJson from(LockFileAccessor dependenciesLockFile) {
    return new LockfileJson(requireNonNull(dependenciesLockFile));
  }

  public LockedProject read() throws MojoExecutionException {
    JsonNode json = readJsonNode();
    if (!json.isObject()) {
      throw new IllegalStateException("Expected top level type to be an object");
    }
    return fromJson(json);
  }

  private static LockedProject fromJson(JsonNode json) throws MojoExecutionException {
    final JsonNode version = json.get("version");
    if (version == null) {
      return LockedProject.from(loadDependenciesFromJson(JsonUtils.getDependencies(json)));
    } else if (V2.equals(version.asText())) {
      final Map<String, Artifact> artifactMap = JsonUtils.loadArtifactsFromJson(getArtifacts(json));
      final Optional<Plugins> plugins = loadPluginsIfPresent(json, artifactMap);
      Optional<Extensions> extensions = loadExtensionsIfPresent(json, artifactMap);
      final Dependencies projectDependencies =
          JsonUtils.loadDependenciesFromJson(JsonUtils.getDependencies(json), artifactMap);
      Optional<Parents> parents = loadParentsIfPresent(json);
      return LockedProject.from(projectDependencies, parents, plugins, extensions);
    } else if (V3.equals(version.asText())) {
      final Map<String, Artifact> artifactMap = JsonUtils.loadArtifactsFromJson(getArtifacts(json));
      final Optional<Plugins> plugins = loadPluginsIfPresent(json, artifactMap);
      Optional<Extensions> extensions = loadExtensionsIfPresent(json, artifactMap);
      Optional<Parents> parents = loadParentsIfPresent(json);
      final Dependencies projectDependencies =
          JsonUtils.loadDependenciesFromJson(JsonUtils.getDependencies(json), artifactMap);
      final Map<String, Dependencies> dependenciesByProfileId =
          JsonUtils.loadProfilesFromJson(json, artifactMap);
      final Profiled<Dependency, Dependencies> dependencies =
          new Profiled<>(projectDependencies, dependenciesByProfileId);
      return LockedProject.from(dependencies, parents, plugins, extensions);

    } else {
      throw new MojoExecutionException(
          format(
              ROOT,
              "Unexpected lock file version \"%s\". The file might have been generated by a newer"
                  + " version of this plugin than is used for this check.",
              version.asText()));
    }
  }

  private static Optional<Parents> loadParentsIfPresent(JsonNode json) {
    return Optional.ofNullable(json.get("parents"))
        .map(parentsNode -> loadParentsFromJson(parentsNode));
  }

  private static Optional<Extensions> loadExtensionsIfPresent(
      JsonNode json, Map<String, Artifact> artifactMap) {
    return Optional.ofNullable(json.get("extensions"))
        .map(extensionsNode -> loadExtensionsFromJson(extensionsNode, artifactMap));
  }

  private static Optional<Plugins> loadPluginsIfPresent(
      JsonNode json, Map<String, Artifact> artifactMap) {
    return Optional.ofNullable(json.get("plugins"))
        .map(pluginsNode -> loadPluginsFromJson(pluginsNode, artifactMap));
  }

  private static JsonNode getArtifacts(JsonNode json) {
    final JsonNode artifacts = json.get("artifacts");
    if (artifacts == null) {
      throw new IllegalStateException("Missing artifacts field");
    }
    return artifacts;
  }

  private static Parents loadParentsFromJson(JsonNode json) {
    ArrayList<Parent> parents = new ArrayList<>();
    if (!json.isArray()) {
      throw new IllegalStateException("Expected parents field to be an array");
    }
    for (JsonNode node : json) {
      parents.add(
          Parent.builder()
              .artifactIdentifier(
                  ArtifactIdentifier.builder()
                      .groupId(getNonBlankStringValue(node, "groupId"))
                      .artifactId(getNonBlankStringValue(node, "artifactId"))
                      .type("pom")
                      .build())
              .version(getNonBlankStringValue(node, "version"))
              .integrity(getNonBlankStringValue(node, "integrity"))
              .build());
    }
    return new Parents(parents);
  }

  private static Dependencies loadDependenciesFromJson(JsonNode json) {
    if (!json.isArray()) {
      throw new IllegalStateException("Needs to be an array");
    }
    final List<Dependency> dependencies = new ArrayList<>(json.size());
    for (JsonNode dependency : json) {
      final Artifact artifact = JsonUtils.parseArtifact(dependency);
      final String scope = possiblyGetStringValue(dependency, "scope").orElse(null);
      final boolean optional = dependency.get("optional").asBoolean();
      dependencies.add(Dependency.forArtifact(artifact).scope(scope).optional(optional).build());
    }
    return Dependencies.fromDependencies(dependencies);
  }

  private static Plugins loadPluginsFromJson(JsonNode json, Map<String, Artifact> artifacts) {
    if (!json.isArray()) {
      throw new IllegalStateException("Needs to be an array");
    }
    List<Plugin> lockedPlugins = new ArrayList<>();
    for (JsonNode entry : json) {
      lockedPlugins.add(lockedPluginFromJson(entry, artifacts));
    }
    return Plugins.from(lockedPlugins);
  }

  private static Extensions loadExtensionsFromJson(JsonNode json, Map<String, Artifact> artifacts) {
    if (!json.isArray()) {
      throw new IllegalStateException("Needs to be an array");
    }
    final List<Extension> lockedPlugins = new ArrayList<>(json.size());
    for (JsonNode entry : json) {
      lockedPlugins.add(lockedExtensionFromJson(entry, artifacts));
    }
    return Extensions.from(lockedPlugins);
  }

  private static Plugin lockedPluginFromJson(JsonNode json, Map<String, Artifact> artifacts) {
    final String artifactKey = getNonBlankStringValue(json, "artifact");
    final Artifact artifact = artifacts.get(artifactKey);
    if (null == artifact) {
      throw new IllegalArgumentException("Artifact not found: " + artifactKey);
    }
    final Plugin.ArtifactsBuilderStage builderStage = Plugin.forArtifact(artifact);
    JsonNode dependenciesNode = json.get("dependencies");
    final List<Artifact> dependencies;
    if (null == dependenciesNode) {
      dependencies = Collections.emptyList();
    } else {
      if (!dependenciesNode.isArray()) {
        throw new IllegalStateException("Needs to be an array");
      }
      dependencies = new ArrayList<>(dependenciesNode.size());
      for (JsonNode dependency : dependenciesNode) {
        final String dependencyKey = dependency.asText();
        final Artifact artifactDependency = artifacts.get(dependencyKey);
        if (null == artifactDependency) {
          throw new IllegalArgumentException("Dependency not found: " + dependencyKey);
        }
        dependencies.add(artifactDependency);
      }
    }
    return builderStage.artifacts(Artifacts.fromArtifacts(dependencies)).build();
  }

  private static Extension lockedExtensionFromJson(JsonNode json, Map<String, Artifact> artifacts) {
    final String artifactKey = getNonBlankStringValue(json, "artifact");
    final Artifact artifact = artifacts.get(artifactKey);
    if (null == artifact) {
      throw new IllegalArgumentException("Artifact not found: " + artifactKey);
    }
    return Extension.of(artifact);
  }

  private JsonNode readJsonNode() {
    try (Reader reader = dependenciesLockFile.reader()) {
      return readJson(reader);
    } catch (IOException e) {
      throw new UncheckedIOException(e);
    }
  }

  public void write(LockedProject contents) {
    JsonNode json = write(contents, JsonNodeFactory.instance);
    try (Writer writer = dependenciesLockFile.writer()) {
      JsonUtils.writeJson(writer, json);
    } catch (IOException e) {
      throw new UncheckedIOException(e);
    }
  }

  private JsonNode write(LockedProject contents, JsonNodeFactory jsonNodeFactory) {
    ObjectNode json = jsonNodeFactory.objectNode();
    json.put("version", V3);
    json.set(
        "artifacts", JsonUtils.buildArtifactsJson(collectArtifacts(contents), jsonNodeFactory));
    contents.parents.ifPresent(parents -> json.set("parents", toJson(parents, jsonNodeFactory)));
    contents.plugins.ifPresent(plugins -> json.set("plugins", toJson(plugins, jsonNodeFactory)));
    contents.extensions.ifPresent(
        extensions -> json.set("extensions", toJson(extensions, jsonNodeFactory)));
    json.set(
        "dependencies",
        JsonUtils.buildDependenciesJson(
            contents.dependencies.getDefaultEntities(), jsonNodeFactory));
    json.set(
        "profiles",
        JsonUtils.buildProfilesJson(contents.dependencies.profileEntries(), jsonNodeFactory));
    return json;
  }

  private Stream<Artifact> collectArtifacts(LockedProject contents) {
    Stream<Artifact> result = contents.dependencies.artifacts();
    result = Stream.concat(result, contents.plugins.map(Plugins::artifacts).orElse(Stream.empty()));
    result =
        Stream.concat(
            result,
            contents
                .extensions
                .map(LockableEntitiesWithArtifact::artifacts)
                .orElse(Stream.empty()));
    return result;
  }

  private JsonNode toJson(Plugins plugins, JsonNodeFactory jsonNodeFactory) {
    ArrayNode json = jsonNodeFactory.arrayNode();
    for (Plugin lockedPlugin : plugins) {
      json.add(toJson(lockedPlugin, jsonNodeFactory));
    }
    return json;
  }

  private JsonNode toJson(Extensions extensions, JsonNodeFactory jsonNodeFactory) {
    ArrayNode json = jsonNodeFactory.arrayNode();
    for (Extension extension : extensions) {
      json.add(toJson(extension, jsonNodeFactory));
    }
    return json;
  }

  private JsonNode toJson(Plugin lockedPlugin, JsonNodeFactory jsonNodeFactory) {
    ObjectNode json = jsonNodeFactory.objectNode();
    json.put("artifact", lockedPlugin.toString_withoutIntegrity());
    ArrayNode dependencies = jsonNodeFactory.arrayNode();
    for (Artifact artifact : lockedPlugin.dependencies) {
      dependencies.add(artifact.getArtifactKey());
    }
    json.set("dependencies", dependencies);
    return json;
  }

  private JsonNode toJson(Extension lockedExtension, JsonNodeFactory jsonNodeFactory) {
    ObjectNode json = jsonNodeFactory.objectNode();
    json.put("artifact", lockedExtension.getArtifactKey());
    return json;
  }

  private JsonNode toJson(Parents lockedParents, JsonNodeFactory jsonNodeFactory) {
    ArrayNode jsonParentsArray = jsonNodeFactory.arrayNode(lockedParents.size());
    for (Parent lockedParent : lockedParents) {
      ObjectNode json = jsonNodeFactory.objectNode();
      final ArtifactIdentifier artifactIdentifier = lockedParent.getArtifactIdentifier();
      json.put("groupId", artifactIdentifier.groupId);
      json.put("artifactId", artifactIdentifier.artifactId);
      json.put("version", lockedParent.getVersion());
      json.put("type", artifactIdentifier.type);
      json.put("integrity", lockedParent.getIntegrityForLockFile());
      jsonParentsArray.add(json);
    }
    return jsonParentsArray;
  }
}
